#This program generates the author-author citation links(edges) and also labels them as 'inside' links or 'outside' links.
#sys.argv[1]-->folder path of journal
#Input: dblp_papers.csv(file that contains the paper-ids, author-ids and reference-ids for all the papers in DBLP) and journal_papers.txt(file that contains the paper-ids, author-ids and reference-ids for all the papers in journal 'j')
#Output: labelled_cit_network.txt(file that contains the citation links with their corresponding label as either 'inside' or 'outside')


import csv
import sys

paper_ids_dblp = [] #This list will hold all the paper ids published in DBLP
paper_ids_journal = [] #This list will hold all the paper ids published in the concerned journal
rows_journal = [] #This list will hold all the rows in the concerned journal. One row per list index.
rows_dblp = [] #This list will hold all the rows in the DBLP. One row per list index.
author_ids_journal=[] #This list will hold the set of all author ids in the journal
count=0 #This is a simple counter that increments with visiting each row in rows_journal



#The file labelled_cit_network contains the citation links with inside and outside labels.This is the output file generated by this program.
with open(sys.argv[1]+"/labelled_cit_network.txt",'w') as openfile:
	openfile.write('')


#Binary Search is used to search the index of the paper id at O(logn) time.	
def Binary_Search(arr, x): 
	low = 0
	high = len(arr) - 1
	mid = 0
  
	while low <= high:
  
		mid = (high + low) // 2
  
        # Check if x is present at mid 
		if arr[mid] < x: 
			low = mid + 1
  
        # If x is greater, ignore left half 
		elif arr[mid] > x: 
			high = mid - 1
  
        # If x is smaller, ignore right half 
		else: 
			return mid 
  
    # If we reach here, then the element was not present 
	return -1


# dblp_papers.csv is the csv file that contains paper-id, author-ids and reference-ids of DBLP in each row.
with open (sys.argv[1]+"/dblp_papers.csv",mode='r') as csv_file:
#Each row contains paper_ids,author_ids and references.
	csv_reader= csv.reader(csv_file, delimiter=',')
	for row in csv_reader:
		paper_ids_dblp.append(int(row[0]))#row[0] contains the paper-id	in a row of dblp_papers.csv
		rows_dblp.append(row)
		
print(len(paper_ids_dblp))

#sys.argv[1] is the folder path of the concerned journal. 
#journal_papers.txt is the contains the set of paper-id, author-ids and reference-ids for the concerned journal in each row.
with open (sys.argv[1]+"/journal_papers.txt",mode='r') as csv_file:
#Each row contains paper_ids,author_ids and references.
	csv_reader= csv.reader(csv_file, delimiter=',')
	for row in csv_reader:
		paper_ids_journal.append(int(row[0]))#row[0] contains the paper-id in a row of sys.argv[1]_papers.txt
		author_row=row[1].split()#row[1] contains the author-ids of a paper.
		for author in author_row:
			author_ids_journal.append(int(author))
		author_ids_journal.sort()#author ids have to be sorted because Binary search requires the sorted input
		rows_journal.append(row)
		
	print(len(paper_ids_journal))
	print(len(paper_ids_dblp))
	
	for row in rows_journal:	
		author_ids=row[1].split(' ')#row[1] contains the author-ids of a paper each separated by a space.
		author_ids.pop()
		
		count+=1
		print(f'{count}')
								
		authors = []
		references = []
		inside_authors = []
		outside_authors = []
		
		for author in author_ids:
			authors.append(author)
		
		reference_ids=row[2].split(' ')#row[1] contains the reference-ids of a paper each separated by a space.
		
		for reference in reference_ids:
			if reference!='0':	# if valid reference ids are found append them to references.
				references.append(reference)
			else:
				break
		size=len(references)
		
		if size>0: #if references are found
		
			for reference in references:	
				#find index and do the connections
				if reference!='':
					index = Binary_Search(paper_ids_journal, int(reference))#search the reference id in the list of paper ids of the journal using binary search
					if index!=-1:#if reference id is found within the the list of paper_ids_journal,
						label= "inside"
						author_ids=rows_journal[index][1].split(' ')#append the set of authors for the matched reference
						author_ids.pop()

						for author in author_ids:
							auth_index= Binary_Search(author_ids_journal,int(author))#Search the author id within the author set of the journal
							if auth_index!=-1:#If the author is in the set author_ids_journal
								inside_authors.append(author)
							
					else:#If the reference id is not found in the paper_ids_journal, search it in the paper_ids_dblp
						
						if reference!='':
							index2 = Binary_Search(paper_ids_dblp, int(reference))
							if index2!=-1:#if the reference id is found in paper_ids_dblp 
								label="outside"
								row2=rows_dblp[index2][1].split(' ')
								row2.pop()
						
								for author in row2:
									auth_index= Binary_Search(author_ids_journal,int(author))#Search if the author id is present within the set of author ids of the journal
									if auth_index!=-1:#If the author is found within author_ids_journal
										outside_authors.append(author)
								
									
							
			for author1 in authors:#for every author in the row
				for author2 in inside_authors:#for every author in inside_authors 
					with open(sys.argv[1]+"/labelled_cit_network.txt",'a') as openfile:	
							openfile.write(f'{author1} {author2} inside\n')#mark the label of the citation link as inside
				for author2 in outside_authors:#for every author in outside_authors
					with open(sys.argv[1]+"/labelled_cit_network.txt",'a') as openfile:	
							openfile.write(f'{author1} {author2} outside\n')#mark the label of the citation link as outside
			
									 					
